# 第六章：Shell 语法

## 简单的命令与管道

一个简单的命令是一个由空格分开的单词组成的可选的参数赋值序列，且在其中可以使用重定向。有关参数位置的描述，请参见 %% 一节的开头。

第一个单词是要执行的命令，其余的单词（如果有）则是该命令的参数。如果给出了命令名称，则在执行命令时，对参数的赋值会改变命令的环境。一个简单命令的值是其返回值，若命令被信号终止，则是128 加上信号编号。例如：
```zsh
echo foo
```
是一个带有参数的简单命令。

管道既可以是简单命令，也可以是两个或多个简单命令的序列，其中每个命令之间用 `|` 或 `|＆` 分隔。如果命令之间用 `|` 分隔，则第一个命令的标准输出将连接到下一个命令的标准输入。 `|＆` 是 `2>＆1 |` 的简写，它将命令的标准输出和标准错误连接到下一个的标准输入。除非管道前面加有 `!`，管道的值就是最后一条命令的返回值。如果有 `!`，管道的值就是是最后一条命令的返回值的逻辑反。例如，
```zsh
echo foo | sed 's/foo/bar/'
```
是管道，第一个命令的输出（`foo` 加一个换行符）将传递给第二个命令的输入。

如果管道前面带有 `coproc`，则将其作为协进程（coprocess）执行并在它和父 shell 之间建立了一条双向管道。父 shell 可以通过 `>＆p` 和 `<＆p` 重定向操作符或通过 `print -p` 和 `read -p` 来读取或写入协进程。管道之前不能同时带有 `coproc` 和 `!`。如果启用了作业管理，则可以将协进程视为输入和输出，而不是普通的后台作业。

子列表可以是单个管道，也可以是由 `&&` 或 `||` 分隔的两个或多个管道的序列。如果两个管道用 `&&` 分隔，则仅当第一个管道成功（返回零状态）时才执行第二个管道。如果两个管道用 `||` 分隔，则仅当第一个失败（返回非零状态）时才执行第二个管道。两个运算符具有相同的优先级，并且是左结合的。子列表的值是最后执行的管道的值。例如，
```zsh
dmesg | grep panic && print yes
```
是一个由两个管道组成的子列表，第二个管道只是一个简单命令，仅当 `grep` 命令返回零状态时才会执行。若返回值不为零，则子列表的返回值为第一个的返回值，否则则为 `print` 的返回值（几乎肯定为零）。

列表是由以 `;`、`＆`、`＆|`、`＆!` 或换行符结尾的零个或多个子列表的序列。若列表作为出现在圆括号或花括号之间的复杂命令，最后一个子列表的终止符可以省略。当子列表以分号或换行符终止时，shell 将在执行下一个子列表之前等待其完成。如果子列表以 `＆`，`＆|` 或 `＆!` 终止，则 shell 将在后台执行它的最后一个管道，并且不等待其完成（请注意 zsh 与其他 shell 的区别在于 zsh 会在后台执行整个子列表）。在这种情况下，后台管道返回零状态。

更一般地，列表可以看作是任何 shell 命令的集合，且包含以下复杂命令。请注意下文中出现“列表”一词时，都隐含这一种情况。例如，shell 函数中的命令形成了一种特殊的列表。
